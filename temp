	d2_getleg: function () {
		this.getLeg = function () {
			var i, portal, wirt, leg, gid;

			if (me.getItem(88)) {
				return me.getItem(88);
			}

			Pather.useWaypoint(4);
			Precast.doPrecast(true);
			Pather.moveToPreset(me.area, 1, 737, 8, 8);

			for (i = 0; i < 6; i += 1) {
				portal = Pather.getPortal(38);

				if (portal) {
					Pather.usePortal(null, null, portal);

					break;
				}

				delay(500);
			}

			if (!portal) {
				throw new Error("Tristram portal not found");
			}

			Pather.moveTo(25048, 5177);

			wirt = getUnit(2, 268);

			for (i = 0; i < 8; i += 1) {
				wirt.interact();
				delay(500);

				leg = getUnit(4, 88);

				if (leg) {
					gid = leg.gid;

					Pickit.pickItem(leg);
					Town.goToTown();

					return me.getItem(-1, -1, gid);
				}
			}

			throw new Error("Failed to get the leg");
		};
		this.getTome = function () {
			var tome,
				myTome = me.findItem("tbk", 0, 3),
				akara = Town.initNPC("Shop");

			tome = me.getItem("tbk");

			if (tome) {
				do {
					if (!myTome || tome.gid !== myTome.gid) {
						return copyUnit(tome);
					}
				} while (tome.getNext());
			}
			
			if (!akara) {
				throw new Error("Failed to buy tome");
			}

			tome = akara.getItem("tbk");

			if (tome.buy()) {
				tome = me.getItem("tbk");
				
				if (tome) {
					do {
						if (!myTome || tome.gid !== myTome.gid) {
							return copyUnit(tome);
						}
					} while (tome.getNext());
				}
			}

			throw new Error("Failed to buy tome");
		};


		this.buildCowRooms = function () {
			var i, j, room, kingPreset, badRooms, badRooms2,
				finalRooms = [],
				indexes = [];

			kingPreset = getPresetUnit(me.area, 1, 773);
			badRooms = getRoom(kingPreset.roomx * 5 + kingPreset.x, kingPreset.roomy * 5 + kingPreset.y).getNearby();

			for (i = 0; i < badRooms.length; i += 1) {
				badRooms2 = badRooms[i].getNearby();

				for (j = 0; j < badRooms2.length; j += 1) {
					if (indexes.indexOf(badRooms2[j].x + "" + badRooms2[j].y) === -1) {
						indexes.push(badRooms2[j].x + "" + badRooms2[j].y);
					}
				}
			}

			room = getRoom();

			do {
				if (indexes.indexOf(room.x + "" + room.y) === -1) {
					finalRooms.push([room.x * 5 + room.xsize / 2, room.y * 5 + room.ysize / 2]);
				}
			} while (room.getNext());

			return finalRooms;
		};

		this.clearCowLevel = function () {
			var room, result, myRoom,
				rooms = this.buildCowRooms();

			function RoomSort(a, b) {
				return getDistance(myRoom[0], myRoom[1], a[0], a[1]) - getDistance(myRoom[0], myRoom[1], b[0], b[1]);
			}

			while (rooms.length > 0) {
				// get the first room + initialize myRoom var
				if (!myRoom) {
					room = getRoom(me.x, me.y);
				}

				if (room) {
					if (room instanceof Array) { // use previous room to calculate distance
						myRoom = [room[0], room[1]];
					} else { // create a new room to calculate distance (first room, done only once)
						myRoom = [room.x * 5 + room.xsize / 2, room.y * 5 + room.ysize / 2];
					}
				}

				rooms.sort(RoomSort);
				room = rooms.shift();

				result = Pather.getNearestWalkable(room[0], room[1], 10, 2);

				if (result) {
					Pather.moveTo(result[0], result[1], 3);

					if (!Attack.clear(30)) {
						return false;
					}
				}
			}

			return true;
		};
		me.overhead("Retrieving leg...");
		myTroops.my_townThings(1, true, "waypoint", 6000, 8000, false);
		say("yoyo");
		
		//leg = this.getLeg();
		if(!this.getLeg()) return false;
		
		myTroops.my_townThings(1, true, "stash", 6000, 8000, false);
		me.overhead("waiting for cow portal...");
		delay(250);
		say("yo");
		delay(rand(2000,3000));
		say(Config.BObarb.Towners[0] + " yoyo");
		delay(rand(2000,3000));
		
		while(!Pather.usePortal(39)) { delay(rand(4000,6000)); }
		Pather.makePortal();
		this.clearCowLevel();
		myTroops.my_townThings(1, true, "waypoint", 6000, 8000, false);
	}
